{% extends "basetemplate.html" %}
{% block title %}Weather Watch{% endblock %}
{% block script %}
    {{ super() }}
    <!-- <link rel="stylesheet" href="{{ url_for('static', filename='css/normalize.css') }}">     -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/ion.rangeSlider.css') }}"> 
    <!-- <link rel="stylesheet" href="{{ url_for('static', filename='css/ion.rangeSlider.skinModern.css') }}">  -->
    <!-- <link rel="stylesheet" href="{{ url_for('static', filename='css/ion.rangeSlider.skinFlat.css') }}">      -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/ion.rangeSlider.skinHTML5.css') }}">
    <!-- <link rel="stylesheet" href="{{ url_for('static', filename='css/weather-icons.min.css') }}">  -->
    <style>
        html, body{
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            z-index: 10;
        }
        #map-canvas {
            width: 100%;
            height: 650px;
            /*z-index: 6;*/
        }
        #panel {
            position: relative;
            /*top: 5px;*/
            /*left: 50%;*/
            /*margin-left: -180px;*/
            z-index: 5;
            background-color: #fff;
            padding: 5px;
            /*border: 1px solid #999;*/
        }
        .popup-link {
            transition: opacity ease-in-out .5s;
            display: block;
            position: relative;
            color: white;
            padding: 4px 0 0 8px;
            line-height: 1.5;
            width: 130px;
        }
/*        .slider {
            -webkit-transition: .7s height ease-in-out 10s;
            transition: .7s height ease-in-out 10s;
            background-color: #9d0300;
            height: 6px;
            border-radius: 3px;
            position: relative;
        }*/
        .irs-min, .irs-max {
            display: none;
        }
        .irs-grid-text {
            bottom: 10px;
            background: #428bca;
            border-radius: 1px;
            padding: 1px 2px;
            color: #fff;
        }
        .irs-grid-pol{
            /*color: #428bca;*/
            opacity: 1;
            background: #428bca;
            width: 2px;
        }
        .irs-slider {
            top: 33px;
            width: 20px;
            height: 10px;
            border: 1px solid #AAA;
            background: #DDD;
            background: linear-gradient(to bottom, rgba(255,255,255,1) 0%,rgba(220,220,220,1) 20%,rgba(255,255,255,1) 100%);
            border-radius: 27px;
            -moz-border-radius: 27px;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.3);
            cursor: pointer;
        }
        .irs-bar {
            height: 10px;
            top: 33px;
            border-top: 1px solid #428bca;
            border-bottom: 1px solid #428bca;
            background: #428bca;
            background: linear-gradient(to top, rgba(66,139,202,1) 0%,rgba(127,195,232,1) 100%);
        }
/*        #checkboxes { 
            position: absolute; 
            top: 80px; 
            right: 10px;
            font-family: 'arial', 'sans-serif'; 
            font-size: 14px;
            background-color: white;
            border: 1px solid black;
            padding: 10px 10px 0px 10px;
        }   */     
    </style> 
    <!-- All JS -->
    <script src="{{ url_for('static', filename='js/jquery-2.1.3.min.js') }}"></script>
    <script type="text/javascript" src="{{ url_for('static', filename='js/ion.rangeSlider.min.js') }}"></script>
    <script type="text/javascript" src="{{ url_for('static', filename='js/moment.min.js') }}"></script>
    <script type="text/javascript" src="{{ url_for('static', filename='js/wicket.js') }}"></script>
    <script type="text/javascript" src="{{ url_for('static', filename='js/turf.min.js') }}"></script>
    <script type="text/javascript" src="{{ url_for('static', filename='js/classybrew.min.js') }}"></script>
    <script type="text/javascript" src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDwVA8ANu6c-Zw3KLTbZQH1B9d1r-FrGQw">
    </script>
    <script>
        var map;
        var request;
        var gettingData = false;
        var geocoder;
        var coords;
        var allDateTime = [];
        var cur_date, cur_time_block;
        var myslider;
        var json_results;
        var shownLayer, 
            layer_weather, 
            layer_powergrid;
        // Done so as to call thie vaues defined below only once. Do not know how to incorporate in the function myIDW the same thing.
        var uk_json, extent, samplingGrid, reducedSamplingGrid;
        var uk_geojson = $.getJSON("{{ url_for('static', filename='json/uttarakhand.geojson') }}", function(geojsonObj){
            // console.log('geoJSONtext', geojsonObj);
            uk_json = geojsonObj;
            extent = turf.bbox(uk_json.features[0].geometry);
            var poly = turf.polygon(uk_json.features[0].geometry.coordinates);
            reducedSamplingGrid = {
                type: "FeatureCollection",
                features: []                    
            };
            var cellWidth = 15;
            var units = 'kilometers';
            if (extent) {
                samplingGrid = turf.hexGrid(extent, cellWidth, units);
                for (var i = 0, N = samplingGrid.features.length; i < N; i++) {
                    if(turf.inside(turf.centroid(samplingGrid.features[i]), poly)){
                        reducedSamplingGrid.features.push(samplingGrid.features[i]);
                    }
                }                 
            }
            // console.log('reducedSamplingGrid', reducedSamplingGrid);                     
        });
        // var activeevent, activeinfowindow;
        var myStyles =[
            {
                featureType: "poi",
                elementType: "labels",
                stylers: [
                      { visibility: "off" }
                ]
            }
        ];
        var geoJSON, geoJSON2;
        var infoWindow = new google.maps.InfoWindow({ content: "" });

        google.maps.InfoWindow.prototype.isOpen = function(){
          var map = this.getMap();
          return (map !== null && typeof map !== "undefined");
        }          

        // function myIDW(controlPoints, valueField, b, cellWidth, units) {
        //     // check if field containing data exists..
        //     // var filtered = filter(controlPoints, valueField);
        //     var filtered = controlPoints.features.filter(function (feature) {
        //         return feature.properties &&
        //         feature.properties.hasOwnProperty(valueField);
        //     });           
        //     // console.log('filtered', filtered);
        //     //alternative method
        //     // console.log(controlPoints.features.map(function (feat) { return valueField in feat.properties}));
        //     if (filtered.length !== 0) {
        //         // create a sample square grid
        //         // compared to a point grid helps visualizing the output (like a raster..)
        //         // console.log('uk_geojson', uk_geojson);
        //         var uk_json = JSON.parse(uk_geojson.responseText);
        //         var extent = turf.bbox(uk_json.features[0].geometry);
        //         if (extent) {
        //             var samplingGrid = turf.hexGrid(extent, cellWidth, units);
        //         } else {
        //             var samplingGrid = turf.hexGrid(turf.bbox(controlPoints), cellWidth, units);
        //         };
        //         var N = samplingGrid.features.length;
        //         var poly = turf.polygon(uk_json.features[0].geometry.coordinates);
        //         var reducedSamplingGrid = {
        //             type: "FeatureCollection",
        //             features: []                    
        //         };                
        //         // var N = ptsWithin.features.length;
        //         // for every sampling point..
        //         for (var i = 0; i < N; i++) {
        //             var zw = 0;
        //             var sw = 0;
        //             if(turf.inside(turf.centroid(samplingGrid.features[i]), poly)){
        //                 // calculate the distance from each control point to cell's centroid
        //                 for (var j = 0; j < controlPoints.features.length; j++) {                      
        //                     var d = turf.distance(turf.centroid(samplingGrid.features[i]), controlPoints.features[j], units);
        //                     if (d === 0) {
        //                         zw = controlPoints.features[j].properties[valueField];
        //                     }
        //                     var w = 1.0 / Math.pow(d, b);
        //                     sw += w;
        //                     zw += w * controlPoints.features[j].properties[valueField];
        //                     // write IDW value for each grid cell
        //                     samplingGrid.features[i].properties.z = zw / sw; 
        //                     reducedSamplingGrid.features.push(samplingGrid.features[i]);                            
        //                 }
        //             }
        //         }
        //         // console.log(samplingGrid, reducedSamplingGrid);
        //         return reducedSamplingGrid;
        //     } else {
        //         console.log('Specified Data Field is Missing');
        //     }
        // };
 
        function myIDW(controlPoints, valueField, b, cellWidth, units) {
            // check if field containing data exists..
            // console.log('controlPoints', controlPoints, 'valueField', valueField);
            // var filtered = filter(controlPoints, valueField);
            var filtered = controlPoints.features.filter(function (feature) {
                return feature.properties &&
                feature.properties.hasOwnProperty(valueField);
            });           
            // console.log('filtered', filtered);
            //alternative method
            // console.log(controlPoints.features.map(function (feat) { return valueField in feat.properties}));
            if (filtered.length !== 0) {
                // create a sample square grid
                // compared to a point grid helps visualizing the output (like a raster..)
                // console.log('uk_geojson', uk_geojson);
                // var uk_json = JSON.parse(uk_geojson.responseText);
                // var extent = turf.bbox(uk_json.features[0].geometry);
                if (!extent) {
                    reducedSamplingGrid = turf.hexGrid(turf.bbox(controlPoints), cellWidth, units);
                };
                var N = reducedSamplingGrid.features.length;
                // var poly = turf.polygon(uk_json.features[0].geometry.coordinates);
                // var reducedSamplingGrid = {
                //     type: "FeatureCollection",
                //     features: []                    
                // };                
                // var N = ptsWithin.features.length;
                // for every sampling point..
                for (var i = 0; i < N; i++) {
                    var zw = 0;
                    var sw = 0;
                    // calculate the distance from each control point to cell's centroid
                    for (var j = 0; j < controlPoints.features.length; j++) {                      
                        var d = turf.distance(turf.centroid(reducedSamplingGrid.features[i]), controlPoints.features[j], units);
                        if (d === 0) {
                            zw = controlPoints.features[j].properties[valueField];
                        }
                        var w = 1.0 / Math.pow(d, b);
                        sw += w;
                        zw += w * controlPoints.features[j].properties[valueField];
                        // write IDW value for each grid cell
                        reducedSamplingGrid.features[i].properties.z = zw / sw; 
                        // reducedSamplingGrid.features.push(samplingGrid.features[i]);                            
                    }
                }
                // console.log(samplingGrid, reducedSamplingGrid);
                return reducedSamplingGrid;
            } else {
                console.log('Specified Data Field is Missing');
            }
        };  

        function DateControl(controlDiv, map) {
            // Set CSS for the control border.
            var controlUI = document.createElement('div');
            controlUI.setAttribute("style", "position:relative; padding:5px;overflow-x:hidden;overflow-y:hidden;width:700px;height:80px;cursor:pointer;");
            // controlUI.style.backgroundColor = '#fff';
            // controlUI.style.border = '2px solid #fff';
            // controlUI.style.borderRadius = '3px';
            // controlUI.style.boxShadow = '0 2px 6px rgba(0,0,0,.3)';
            // controlUI.style.cursor = 'pointer';
            // controlUI.style.marginBottom = '22px';
            // controlUI.style.textAlign = 'center';
            // controlUI.title = 'Click to recenter the map';
            controlDiv.appendChild(controlUI);
            
            // Set CSS for the control interior.
            var controlText = document.createElement('input');
            controlText.id = 'range'; 
            // controlText.style.color = 'rgb(25,25,25)';
            // controlText.style.fontFamily = 'Roboto,Arial,sans-serif';
            // controlText.style.fontSize = '16px';
            // controlText.style.lineHeight = '38px';
            // controlText.style.paddingLeft = '5px';
            // controlText.style.paddingRight = '5px';
            // controlText.innerHTML = 'Center Map';
            controlUI.appendChild(controlText);

           //  var control = this;
           //  control.isOpen = true;
           //  // Set CSS for the control border.
           //  var controlUI = document.createElement('input');
           //  controlUI.id = 'range'; 
           //  // controlUI.style.backgroundColor = '#fff';
           //  // controlUI.style.border = '2px solid #fff';
           //  // controlUI.style.borderRadius = '3px';
           //  // controlUI.style.boxShadow = '0 2px 6px rgba(0,0,0,.3)';
           //  // controlUI.style.cursor = 'pointer';
           //  // controlUI.style.marginBottom = '22px';
           //  // controlUI.style.textAlign = 'center';
           //  controlUI.style.position = 'relative';
           //  // controlUI.style.padding = '200px';              
           //  controlDiv.appendChild(controlUI);

           // // Set CSS for the control interior.
           //  // var controlText = document.createElement('div');
           //  // controlText.style.color = 'rgb(25,25,25)';
           //  // controlText.style.fontFamily = 'Roboto,Arial,sans-serif';
           //  // controlText.style.fontSize = '16px';
           //  // controlText.style.lineHeight = '38px';
           //  // controlText.style.paddingLeft = '5px';
           //  // controlText.style.paddingRight = '5px';
           //  // controlText.innerHTML = 'Center';
           //  // controlUI.appendChild(controlText);

           //  // var controlSlider = document.createElement('div');
           //  // controlSlider.id = 'datecontrolslider';
           //  // controlUI.appendChild(controlSlider);

           //  // var controlSlider = document.createElement('div');
           //  // controlSlider.innerHTML = '<input id="range" />';
           //  // controlUI.appendChild(controlSlider);
           //  // var controlSlider = document.createElement('input');
           //  // controlSlider.id = 'dateslider';
           //  // controlUI.appendChild(controlSlider);
           //  console.log($(controlUI));
            // $(controlText).ionRangeSlider({
            //     min: +moment().subtract(12, "hours").format("X"),
            //     max: +moment().format("X"),
            //     from: +moment().subtract(6, "hours").format("X"),
            //     grid: true,
            //     force_edges: true,
            //     prettify: function (num) {
            //         var m = moment(num, "X");
            //         return m.format("Do MMMM, HH:mm");
            //     }
            // });
            $(controlText).ionRangeSlider({
                type: "single",
                // min : +moment(moment(arrayMin(allDateTime)).format('DD-MM-YYYY') + 0, "DD-MM-YYYYh").format('X'),
                // max : +moment(moment(arrayMax(allDateTime)).format('DD-MM-YYYY') + 24, "DD-MM-YYYYh").format('X'),
                // min: +moment("14-10-2016" + 1, "DD-MM-YYYYh").format('X'),
                // max: +moment("20-10-2016" + 24, "DD-MM-YYYYh").format('X'),
                // values: allDateTime,
                grid: true,
                // grid_num: +moment(arrayMax(allDateTime)).diff(moment(arrayMin(allDateTime)), 'days') + 1,
                // grid_num: 7,
                // grid_snap: true,
                force_edges: true,
                prettify: function (num) {
                    var m = moment(num, "x");
                    return m.format("DoMMMYY, HH");
                }
            });
            myslider = $(controlText).data("ionRangeSlider");                                             
        }

        function sliderUpdate() {
            myslider.update({
                min: +moment(arrayMin(allDateTime)).startOf('hour').add(0, 'hours').format('x'),
                max: +moment(arrayMax(allDateTime)).startOf('hour').add(24, 'hours').format('x'),
                grid_num: +moment(arrayMax(allDateTime)).diff(moment(arrayMin(allDateTime)), 'days') + 1,
                from: +moment(cur_date).startOf('hour').add(cur_time_block, 'hours').format('x'),
                from_min: +moment(arrayMin(allDateTime)).startOf('hour').add(1, 'hours').format('x'),
                keyboard: true,
                step: 100,
                // onStart: function (data) {
                //     console.log("onStart", data);
                //     saveResult(data);
                // },
                onChange: function (data) {
                    // console.log("onChange", data);
                    saveResult(data);
                },
                // onFinish: function (data) {
                //     console.log("onFinish", data);
                //     saveResult(data);
                // },
                onUpdate: function (data) {
                    // console.log("onUpdate", data);
                    saveResult(data);
                }                              
            });           
        };

        var saveResult = function (data) {
            // console.log('Slider Value', data.from, moment(data.from).format('DD-MM-YYYY'), moment(data.from).format('H'));
            //filter the json data
            var weatherParam;
            if (json_results.length > 0) {
                // console.log('Results json_results:', json_results);
                resetData();
                for (var i = 0; i < json_results.length; i++) {
                    // console.log('json_results i: ', i, typeof json_results[i]['date'], typeof json_results[i]['hour'], typeof moment(data.from).format('DD-MM-YYYY'), typeof moment(data.from).format('H'));
                    hour = parseInt(moment(data.from).format('H')) === 0 ? 24 : parseInt(moment(data.from).format('H'));
                    date = parseInt(moment(data.from).format('H')) === 0 ? moment(data.from).startOf('hour').subtract(1, 'hours').format('DD-MM-YYYY') : moment(data.from).format('DD-MM-YYYY');
                    // console.log('date : hour', date, hour); 
                    if (json_results[i]['date'] ===  date && json_results[i]['hour'] === hour){
                        geoJSON.features.push(jsonToGeoJson(json_results[i]));
                    }  
                    
                }
                //populate the geojson
                if (document.getElementById('temperature').checked) {
                    weatherParam = document.getElementById('temperature').value;
                } else if (document.getElementById('windspeed').checked) {
                    weatherParam = document.getElementById('windspeed').value;
                } else if (document.getElementById('perc_change_temp_frdaybf').checked) {
                    weatherParam = document.getElementById('perc_change_temp_frdaybf').value;
                } else if (document.getElementById('rainfall').checked) {
                    weatherParam = document.getElementById('rainfall').value;
                } else if (document.getElementById('perc_change_rainfall_frdaybf').checked) {
                    weatherParam = document.getElementById('perc_change_rainfall_frdaybf').value;
                }

                drawIcons(geoJSON, weatherParam);
                // updateInfo();
            }            
        };

        // var updateInfo = function () {
        //     if (activeevent && activeinfowindow){
        //         activeinfowindow.setContent(
        //             "<img src=" + activeevent.feature.getProperty("icon") + ">"
        //             + "<br /><strong>" + activeevent.feature.getProperty("city") + "</strong>"
        //             + "<br />" + activeevent.feature.getProperty("temperature") + "&deg;C"
        //             + "<br />" + activeevent.feature.getProperty("windSpeed") + "&nbsp;" + "Kmph" + "&nbsp;"
        //             +  activeevent.feature.getProperty("windDegrees") + "&deg;"
        //             + "<br />" + activeevent.feature.getProperty("conditions")
        //             + "<br />" + activeevent.feature.getProperty("date")
        //             + "<br />" + activeevent.feature.getProperty("hour")
        //         );
        //         activeinfowindow.setOptions({
        //             position:{
        //                 lat: activeevent.latLng.lat(),
        //                 lng: activeevent.latLng.lng()
        //             },
        //             pixelOffset: {
        //                 width: 0,
        //                 height: -15
        //             }
        //         });
        //         activeinfowindow.open(map);
        //     }
        // };

        function initialize() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(success, failure);
                console.log("In Geolocation");
            } else {
                console.log('Geo Location is not supported');
            }

            function success(position){
                coords = new google.maps.LatLng(position.coords.latitude, position.coords.longitude); 
                console.log("In Success" + position);
                console.log(coords);
                load();
            }

            function failure(){
                coords = new google.maps.LatLng(20,78);
                console.log("In Failure");
                load();
            }
        }

        // var infowindow = new google.maps.InfoWindow();

        // var station = {"type": "FeatureCollection",
        //     "features": [
        //         {
        //             "type": "Feature",
        //             "geometry": {
        //                 "type": "Point",
        //                 "coordinates": [
        //                     30.086928,
        //                     78.267612
        //                 ]
        //             },
        //             "properties": {
        //                 "name": "400_KV_S/S_Rishikesh",
        //                 "division": "Garhwal"
        //             }
        //         },
        //         {
        //             "type": "Feature",
        //             "geometry": {
        //                 "type": "Point",
        //                 "coordinates": [
        //                     29.854263,
        //                     77.888
        //                 ]
        //             },
        //             "properties": {
        //                 "name": "220KV_S/S_Roorkee",
        //                 "division": "Garhwal"
        //             }
        //         },        
        //     ]
        // };

        function load() {
            console.log("Load...");          
            var myOptions = {
                zoom: 12,
                // center: new google.maps.LatLng(20,78),
                center: coords,
                mapTypeId: google.maps.MapTypeId.ROADMAP,
                styles: myStyles,
                clickableIcons: false
            };            
            geocoder = new google.maps.Geocoder();
            // var coords = new google.maps.LatLng(position.coords.latitude, position.coords.longitude);
            var mapOptions = {
                zoom: 8,
                // center: new google.maps.LatLng(20,78),
                center: coords,
                zoomControl: true,
                mapTypeId: google.maps.MapTypeId.HYBRID
            };

            map = new google.maps.Map(document.getElementById('map-canvas'),
                myOptions);
            map.data.setStyle({
                strokeWeight: 0
            });
            layer_powergrid = new google.maps.Data();
            layer_powergrid.setStyle(function(feature) {
                var color = 'gray';
                if (feature.getProperty('color')) {
                    color = feature.getProperty('color');
                }
                if (feature.getProperty('ringoff')) {
                    // size = 24;
                    // point = 12;
                    size = 16;
                    point = 8;                    
                } else {
                    size = 16;
                    point = 8;
                }                 
                return /** @type {google.maps.Data.StyleOptions} */({
                    icon: {
                        url: feature.getProperty('icon'),
                        anchor: new google.maps.Point(point, point),
                        scaledSize : new google.maps.Size(size, size),

                    },                
                    fillColor: color,
                    strokeColor: color,
                    strokeWeight: 2,
                    visible: feature.getProperty('visible')
                });
            });            
            // layer_powergrid.loadGeoJson("{{ url_for('ems.grid_data') }}");
            // layer_powergrid.setMap(map);

            // shownLayer = layer_powergrid;            
            // map.data.addGeoJSON(data);
            // Add interaction listeners to make weather requests
            google.maps.event.addListener(map, 'idle', checkIfDataRequested);
            codeAddress("{{ state }}");
            // Sets up and populates the info window with details
            // layer_powergrid.addListener("click", function(event) {
            //     infoWindow.setContent(
            //         "<strong>" + event.feature.getProperty("name") + "</strong>"
            //         // + "<br />" + event.feature.getProperty("code")
            //         // + "<br />" + "Parent:" + event.feature.getProperty("parent")
            //         // + "<br />" + "Child:" + event.feature.getProperty("child")
            //         // + "<br />" + event.feature.getProperty("capacity")
            //     );
            //     infoWindow.setOptions({
            //         position:{
            //             lat: event.latLng.lat(),
            //             lng: event.latLng.lng()
            //         },
            //         pixelOffset: {
            //             width: 0,
            //             height: -15
            //         }
            //     });
            //     infoWindow.open(map);
            // });            
            layer_powergrid.addListener('mouseover', function(event) {
                infoWindow.setContent(
                    "<strong>" + event.feature.getProperty("name") + "</strong>"
                    // + "<br />" + event.feature.getProperty("code")
                    // + "<br />" + "Parent:" + event.feature.getProperty("parent")
                    // + "<br />" + "Child:" + event.feature.getProperty("child")
                    // + "<br />" + event.feature.getProperty("capacity")
                );
                infoWindow.setOptions({
                    position:{
                        lat: event.latLng.lat(),
                        lng: event.latLng.lng()
                    },
                    pixelOffset: {
                        width: 0,
                        height: -15
                    }
                });
                infoWindow.open(map);
            });
            layer_powergrid.addListener('mouseout', function() {
                infoWindow.setContent(null);
                infoWindow.close();
            }); 
            // Create the DIV to hold the control and call the CenterControl()
            // constructor passing in this DIV.
            var dateControlDiv = document.createElement('div');
            var dateControl = new DateControl(dateControlDiv, map);

            dateControlDiv.index = 1;
            map.controls[google.maps.ControlPosition.BOTTOM_LEFT].push(dateControlDiv);  

            // Color each letter gray. Change the color when the isColorful property
            // is set to true.
            // map.data.setStyle(function(feature) {
            //   var color = 'gray';
            //   if (feature.getProperty('isColorful')) {
            //     color = feature.getProperty('color');
            //   }
            //   return /** @type {google.maps.Data.StyleOptions} */({
            //     fillColor: color,
            //     strokeColor: color,
            //     strokeWeight: 2
            //   });
            // });

            // When the user clicks, set 'isColorful', changing the color of the letters.
            // layer_powergrid.addListener('click', function(event) {
            //   event.feature.setProperty('isColorful', true);
            // });
            layer_powergrid.setMap(map);
            // layer_powergrid.setStyle(function(feature) {  

            //     console.log(feature.getProperty('name'), feature.getProperty('type'),feature.getProperty('type') >= 220 ? 'visible' : 'hidden');
            //   return /** @type {google.maps.Data.StyleOptions}*/ ({
            //     fillColor: feature.getProperty('color'),
            //     strokeColor: feature.getProperty('color'),
            //     strokeWeight: 2,
            //     visible: feature.getProperty('type') >= 400 ? true : false
            //   });
            // });                                            
        } 


        function codeAddress(address) {
            // var address = document.getElementById('address').value;
            var geocoderl = new google.maps.Geocoder();
            geocoderl.geocode( {'address': address}, function(results, status) {
                if (status == google.maps.GeocoderStatus.OK) {
                    map.setCenter(results[0].geometry.location);
                    map.setTilt(0);
                    map.setZoom(8);
                    // var marker = new google.maps.Marker({
                    //     map: map,
                    //     position: results[0].geometry.location
                    // });
                } else {
                    alert('Geocode was not successful for the following reason: ' + status);
                }
            });
        }
        // Enter key implementation but gives CRSF error
        // $('#address').keypress(function(e){
        //     if ( e.which == 13 && document.getElementById("address").value.length > 0){
        //       codeAddress();
        //     }
        // });
        function inArray(needle, haystack) {
            var length = haystack.length;
            for (var i = 0; i < length; i++) {
                if (haystack[i] == needle)
                return true;
            }
            return false;
        };

        function arrayMin(arr) {
            var len = arr.length, min = Infinity;
            while (len--) {
                if (arr[len] < min) {
                  min = arr[len];
                }
            }
            return min;
        };

        function arrayMax(arr) {
            var len = arr.length, max = -Infinity;
                while (len--) {
                if (arr[len] > max) {
                  max = arr[len];
                }
            }
            return max;
        };

        var checkIfDataRequested = function() {
            // Stop extra requests being sent
            while (gettingData === true) {
                request.abort();
                gettingData = false;
            }
            getSubstation();
            getCoords();
            // layer_powergrid.setMap(map);
        };

        // Get the coordinates from the Map bounds
        var getCoords = function() {
            var bounds = map.getBounds();
            var NE = bounds.getNorthEast();
            var SW = bounds.getSouthWest();
            getWeather(NE.lat(), NE.lng(), SW.lat(), SW.lng());
        };

        // Make the weather request
        var getWeather = function(northLat, eastLng, southLat, westLng) {
            gettingData = true;
            // var requestString = "http://api.openweathermap.org/data/2.5/box/city?bbox="
            //                     + westLng + "," + northLat + "," //left top
            //                     + eastLng + "," + southLat + "," //right bottom
            //                     + map.getZoom()
            //                     + "&cluster=yes&format=json"
            //                     + "&APPID=" + openWeatherMapKey;
            var requestString = "weatherwatchdata/"
                            + westLng + "/" + northLat + "/" //left top
                            + eastLng + "/" + southLat  //right bottom 
            request = new XMLHttpRequest();
            request.onload = proccessResults;
            request.open("get", requestString, true);
            request.send();
        };

        // Take the JSON results and proccess them
        var proccessResults = function() {
            // console.log('This:', this);
            var results = JSON.parse(this.responseText);
            json_results = results;
            if (results.length > 0) {
                // console.log('Results:', results);
                // resetData();
                for (var i = 0; i < results.length; i++) {
                    var datetime = +moment(results[i]['date'], "DD-MM-YYYY");
                    cur_date = +moment(results[i]['cur_date'], "DD-MM-YYYY");
                    cur_time_block = results[i]['cur_block_hour_no'];
                    if (!inArray(datetime, allDateTime)){
                        allDateTime.push(datetime);
                    };
                    // geoJSON.features.push(jsonToGeoJson(results[i]));
                }
                // console.log(allDateTime);
                sliderUpdate();                
                // drawIcons(geoJSON);
            }
        };


        // For each result that comes back, convert the data to geoJSON
        var jsonToGeoJson = function (weatherItem) {
            var conditions = weatherItem.conditions ? weatherItem.conditions.replace(/ +/g, ""): weatherItem.conditions;
            // var icon = {
            //     url: "/static/images/weather/png/cloud.png", // url
            //     scaledSize: new google.maps.Size(50, 50), // scaled size
            //     origin: new google.maps.Point(0,0), // origin
            //     anchor: new google.maps.Point(0, 0) // anchor
            // };            
            var feature = {
                type: "Feature",
                properties: {
                    date: weatherItem.date,
                    hour: weatherItem.hour,
                    city: weatherItem.city,
                    // weather: weatherItem.weather[0].main,
                    temperature: weatherItem.temperature,
                    // min: weatherItem.main.temp_min,
                    // max: weatherItem.main.temp_max,
                    // humidity: weatherItem.main.humidity,
                    // pressure: weatherItem.main.pressure,
                    conditions: weatherItem.conditions,
                    windSpeed: weatherItem.windspeed,
                    windDegrees: weatherItem.winddir_deg,
                    perc_change_temp_frdaybf: weatherItem.perc_change_temp_frdaybf,
                    rainfall: weatherItem.rainfall,
                    perc_change_rainfall_frdaybf: weatherItem.perc_change_rainfall_frdaybf,
                    // windGust: weatherItem.wind.gust,
                    // icon: "/static/images/wunderground/"
                    //       + conditions + ".gif",
                    icon: "/static/images/weather_flat_colorful/svg/" + conditions + ".svg",
                    coordinates: [weatherItem.longitude, weatherItem.latitude]
                },
                geometry: {
                    type: "Point",
                    coordinates: [weatherItem.longitude, weatherItem.latitude]
                }
            };
            // Set the custom marker icon
            map.data.setStyle(function(feature) {
                // var iconSize = new google.maps.Size(50, 50);
                var iconAnchor = new google.maps.Point(25, 25);
                var iconScaledSize = new google.maps.Size(50, 50);
                return {
                    icon: {
                        // url: feature.getProperty('icon'),
                        // anchor: new google.maps.Point(25, 25)
                        url: feature.getProperty('icon'),
                        // size: iconSize,
                        // strokeColor: '#FFD700',
                        // strokeWeight: 20,
                        anchor: iconAnchor,
                        scaledSize: iconScaledSize                        
                    }
                };
            });
            // console.log('Geojson obj', JSON.stringify(feature));
            // returns object
            return feature;
        };


        // Add the markers to the map
        var drawIcons = function (geoJSON, weatherParam) {
            // create classification for colors
            // console.log('geoJSON',geoJSON);
            var brew = new classyBrew();
            // console.log('getColorCodes', brew.getColorCodes());
            var values = []; // tmin values
            for( var i = 0; i < geoJSON.features.length; i++) {
                if (geoJSON.features[i].properties[weatherParam] || geoJSON.features[i].properties[weatherParam] === 0) {
                    values.push(geoJSON.features[i].properties[weatherParam]);
                };
            }
            // console.log('values', values);
            brew.setSeries(values);
            brew.setNumClasses(6);
            brew.classify('equal_interval');
            // brew.setColorCode("RdYlBu");
            brew.setColorCode("Paired");               
            // map.data.addGeoJson(geoJSON);
            // var breaks = [];
            // for (var i = 0; i < 50; i++) { breaks.push(i); }
            // var isolined = turf.isolines(geoJSON, 'temperature', 50, breaks);
            // var tin = turf.tin(geoJSON, 'temperature');
            // console.log("tin", tin );
            // map.data.addGeoJson( tin );
            // map.data.addGeoJson(isolined);             
            var idw = myIDW(geoJSON, weatherParam, 3, 15,'kilometers');
            // console.log( "idw", idw );
            // map.data.setStyle({});
            map.data.forEach(function (feature) {
                map.data.remove(feature);
            });
            map.data.addGeoJson( idw );
            map.data.setStyle(function(feature) {
                // console.log('feature', feature.getProperty('a') , feature.getProperty('b') , feature.getProperty('c'), (feature.getProperty('a') + feature.getProperty('b') + feature.getProperty('c'))/3);
                // console.log('brew', brew.getColorInRange((feature.getProperty('a') + feature.getProperty('b') + feature.getProperty('c')) / 3.0, true));
                // return {
                //     weight : 1,
                //     fillColor : (function () {
                //         return brew.getColorInRange((feature.getProperty('a') + feature.getProperty('b') + feature.getProperty('c')) / 3.0, true);
                //     }()),
                //     fillOpacity : 0.85
                // };
                return {
                    strokeWeight: 0,
                    weight : 1,
                    fillColor : (function () {
                        return brew.getColorInRange(feature.getProperty('z'), true);
                    }()),
                    fillOpacity : 0.55,
                    zIndex: -1
                };                
            });
            // click
            // map.data.addListener('click', function(e) {
            //     var anchor = new google.maps.MVCObject();
            //     if( e.feature.getProperty('z') ){
            //         // console.log( e.feature.getProperty('z') );
            //         var unitsObj = {'temperature': "&deg;C", 
            //             'windSpeed': "&nbsp;" + "Kmph" + "&nbsp;",
            //             'perc_change_temp_frdaybf' : '%'
            //         };
            //         // var units = (weatherParam==='temperature') ? "&deg;C" : "&nbsp;" + "Kmph" + "&nbsp;"
            //         // infoWindow.setContent('<div class="map-box">' + e.feature.getProperty('z').toFixed(2)  + units + "</div>");
            //         infoWindow.setContent('<div class="map-box">' + e.feature.getProperty('z').toFixed(2)  + unitsObj[weatherParam] + "</div>");
            //         anchor.set("position", e.latLng);
            //         infoWindow.open(map,anchor);
            //     }
            // });
            map.data.addListener('mouseover', function(e) {
                var anchor = new google.maps.MVCObject();
                if( e.feature.getProperty('z') || e.feature.getProperty('z') === 0){
                    // console.log( e.feature.getProperty('z') );
                    var unitsObj = {'temperature': "&deg;C", 
                        'windSpeed': "&nbsp;" + "Kmph" + "&nbsp;",
                        'perc_change_temp_frdaybf': '%',
                        'rainfall': 'mm',
                        'perc_change_rainfall_frdaybf': '%'
                    };
                    // var units = (weatherParam==='temperature') ? "&deg;C" : "&nbsp;" + "Kmph" + "&nbsp;"
                    // infoWindow.setContent('<div class="map-box">' + e.feature.getProperty('z').toFixed(2)  + units + "</div>");
                    infoWindow.setContent('<div class="map-box">' + e.feature.getProperty('z').toFixed(2)  + unitsObj[weatherParam] + "</div>");
                    anchor.set("position", e.latLng);
                    infoWindow.open(map,anchor);
                }
            });
            map.data.addListener('mouseout', function() {
                infoWindow.setContent(null);
                infoWindow.close();
            });                        
        }

        // Clear data layer and geoJSON
        var resetData = function () {
            geoJSON = {
                type: "FeatureCollection",
                features: []
            };
            map.data.forEach(function(feature) {
                map.data.remove(feature);
            });
            geoJSON2 = {
                type: "FeatureCollection",
                features: []
            };
            // layer_powergrid.forEach(function(feature) {
            //     layer_powergrid.remove(feature);
            // });            
        };

        // make sure your map is a global
        function toggleLayer(this_layer){
           if( this_layer.getMap() ){
                this_layer.setMap(null);
           }else{
                this_layer.setMap(map);
           }
        };

        // Set the stroke width, and fill color for each polygon
        // Add some style.
        // layer_powergrid.setStyle(function(feature) {
        //     console.log('xxx', feature);
        //   return /** @type {google.maps.Data.StyleOptions} */({
        //     fillColor: feature.getProperty('color'),
        //     strokeColor: feature.getProperty('color'),
        //     strokeWeight: 2
        //   });
        // });
        // map.data.setStyle({
        //   fillColor: 'green',
        //   strokeWeight: 2
        // });
        var getSubstation = function() {
            // console.log('getSubstation called ****');
            gettingData = true;
            requestString = "{{ url_for('ems.grid_data') }}";
            // requestString = "get_substation/" + "D";
            request = new XMLHttpRequest();
            request.onload = proccessResultsSubSt;
            request.open("get", requestString, true);
            request.send();
        };
        // Take the JSON results and proccess them
        var proccessResultsSubSt = function() {
            // console.log('This:', this);
            var results = JSON.parse(this.responseText);
            if (results.length > 0) {
                // console.log('Results:', results);
                resetData();
                for (var i = 0; i < results.length; i++) {
                    if (results[i].parent_flag === 1){
                        addPts(jsonToGeoJsonParPt(results[i]));
                        addPts(jsonToGeoJsonCldPt(results[i]));                        
                    } else {
                        addPts(jsonToGeoJsonCldPt(results[i]));  
                    }

                    if (results[i].child_lat != null){
                        geoJSON2.features.push(jsonToGeoJsonLine(results[i]));
                        // drawRingOffCircle(results[i]);
                    }
                }
                setGeojsonLayer(geoJSON2);
            }
            // console.log('geoJSON2', JSON.stringify(geoJSON2));
        };

        var setGeojsonLayer = function (geojson) {
            // // map.data.addGeoJson(geoJSON);
            // console.log('geojson', JSON.stringify(geojson));
            layer_powergrid.addGeoJson(geojson);
            // Set the flag to finished
            gettingData = false;
        };

        function addPts(point) {
            // console.log('point', point);
            var found = false;
            for(var i = 0; i < geoJSON2.features.length; i++) {
                if (geoJSON2.features[i].properties.name === point.properties.name && geoJSON2.features[i].properties.type === point.properties.type) {
                    found = true;
                    break;
                }
            }
            // if (geoJSON.features.indexOf(point) === -1) {
            //     geoJSON.features.push(point);
            // }
            if (!found) {
                geoJSON2.features.push(point);
            }
            // console.log(geoJSON.features, point);
        };        
        // For each result that comes back, convert the data to geoJSON
        var jsonToGeoJsonParPt = function (rowItem) {
            var icon;
            if (rowItem.parent_flag === 1){
                icon = "start_substation_" + "green" + ".svg";
            } else {
                icon = "substation_" + "green" + ".svg";
            }            
            var feature = {
                type: "Feature",
                geometry: {
                    type: "Point",
                    coordinates: [rowItem.par_long, rowItem.par_lat]
                },
                properties: {
                    name: rowItem.parent_name,
                    code: rowItem.parent_code,
                    // capacity: rowItem.output_rating,
                    // parent: rowItem.parent,
                    // child: rowItem.child,
                    ringoff: rowItem.ringoff_ind,
                    type: rowItem.substation_type_name,                    
                    icon: "/static/images/substation/" + icon,
                    visible: true,
                    id: rowItem.parent,
                    loop_no: rowItem.loop_no
                }                
            };
            return feature;
        };

        var jsonToGeoJsonCldPt = function (rowItem) {
            var icon = "substation_" + "green" + ".svg";
            if (rowItem.ringoff_ind === 1){
                // icon = "ringoff_substation_" + "south" + "_energized.svg";  
                icon = "substation_" + "ringoff" + ".svg";              
            } else {
                icon = "substation_" + "green" + ".svg";
            }             
            var feature = {
                type: "Feature",
                geometry: {
                    type: "Point",
                    coordinates: [rowItem.child_long, rowItem.child_lat]
                },
                properties: {
                    name: rowItem.child_name,
                    code: rowItem.child_code,
                    // capacity: rowItem.output_rating,
                    // parent: rowItem.parent,
                    // child: rowItem.child,
                    ringoff: rowItem.ringoff_ind,
                    type: rowItem.substation_type_name,
                    icon: "/static/images/substation/" + icon,
                    visible: true,
                    id: rowItem.child,
                    loop_no: rowItem.loop_no
                }                
            };            
            return feature;
        };

        var jsonToGeoJsonLine = function (rowItem) {
            // console.log('connection', rowItem.connection);
            if (rowItem.connection === null){
                var feature = {
                    type: "Feature",
                    geometry: {
                        type: "LineString",
                        coordinates: [[rowItem.par_long, rowItem.par_lat],
                                      [rowItem.child_long, rowItem.child_lat]]
                    },
                    properties: {
                        color: "red",
                        type: rowItem.substation_type_name,  
                        visible: true,
                        ringoff: rowItem.ringoff_ind,
                        normally_open: rowItem.normally_open_ind,
                        loop_no: rowItem.loop_no,
                        from: rowItem.parent_code,
                        to: rowItem.child_code,
                        from_id: rowItem.parent,
                        to_id: rowItem.child                          
                    }                
                };                
            } else {
                // Converting WKT to JSON
                wkt = new Wkt.Wkt();
                // Create a geometry object, ready to be mapped!
                wkt.read(rowItem.connection)
                var geometry = wkt.toJson(); // Outputs an object
                var feature = {
                    type: "Feature",
                    geometry,
                    properties: {
                        color: "red",
                        type: rowItem.substation_type_name,
                        visible: true,
                        ringoff: rowItem.ringoff_ind,
                        normally_open: rowItem.normally_open_ind,
                        loop_no: rowItem.loop_no,
                        from: rowItem.parent_code,
                        to: rowItem.child_code,
                        from_id: rowItem.parent,
                        to_id: rowItem.child                                     
                    }                
                };                                                
            }
            // console.log('linefeature', JSON.stringify(feature));                      
            return feature;
        };                        

        function changeLayer(layerselection) {
            console.log(layerselection);            
            if (layerselection === "weather"){
                if (document.getElementById(layerselection).checked == true) {
                   if (layer_weather.getMap() == null) layer_weather.setMap(map); 
                }
                else if (document.getElementById(layerselection).checked == false) {
                     layer_weather.setMap(null); /*layersetoff*/
                }
            }
            else if (layerselection === "powergrid"){
                if (document.getElementById(layerselection).checked == true) {
                   if (layer_powergrid.getMap() == null) layer_powergrid.setMap(map); 
                }
                else if (document.getElementById(layerselection).checked == false) {
                     layer_powergrid.setMap(null); /*layersetoff*/
                }                
            }
        }        

        google.maps.event.addDomListener(window, 'load', function () {
            initialize();
        });
    </script>          
{% endblock %}
{% block header %}
    <form id="defaultForm" method="post" class="navbar-form navbar-left form-inline" role="form">
        <div class="row">                          
<!--             <div class="form-group">
                <input class="form-control" id="address" type="textbox" value="UTTARAKHAND">
                <input type="button" class="btn btn-primary" value="Geocode" onclick="codeAddress(document.getElementById('address').value)">
            </div> -->
            <label class="radio-inline">
              <input type="radio" id="temperature" value="temperature" name="optradio" checked="checked" onclick="drawIcons(geoJSON, this.value)">Temperature
            </label>
            <label class="radio-inline">
              <input type="radio" id="perc_change_temp_frdaybf" value="perc_change_temp_frdaybf" name="optradio" onclick="drawIcons(geoJSON, this.value)">% Temperature Change
            </label> 
            <label class="radio-inline">
              <input type="radio" id="windspeed" value="windSpeed" name="optradio" onclick="drawIcons(geoJSON, this.value)">Windspeed
            </label>                                                  
<!--             <input type="checkbox" value="temperature" id="temperature" onclick="changeWeatherParam(this.value);" checked="checked">Temperature
            <input type="checkbox" value="windspeed" id="windspeed" onclick="changeWeatherParam(this.value);">Windspeed  -->                   
        </div>
        <div class="row">
            <label class="radio-inline">
              <input type="radio" id="rainfall" value="rainfall" name="optradio" onclick="drawIcons(geoJSON, this.value)">Rainfall
            </label>
            <label class="radio-inline">
              <input type="radio" id="perc_change_rainfall_frdaybf" value="perc_change_rainfall_frdaybf" name="optradio" onclick="drawIcons(geoJSON, this.value)">% Rainfall Change
            </label>          
        </div>
    </form>    
{% endblock %}
{% block content %}
<!-- Page contents -->
<!--     <div id="panel">
        <div>
            <input id="range"/>
        </div>
    </div> -->
    <div id="map-canvas"></div>
<!--     <div id="checkboxes">
        <form>
            <input type="checkbox" value="weather" id="weather" onclick="changeLayer(this.value);" checked="checked">Weather<br>
            <input type="checkbox" value="powergrid" id="powergrid" onclick="changeLayer(this.value);" checked="checked">Powergrid<br>
        </form>
    </div>   -->     
{% endblock %}